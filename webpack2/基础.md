# 抽离公共代码块
```js
optimization: {
        // 压缩 css
        minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})],

        // 分割代码块
        splitChunks: {
            chunks: 'all',
            /**
             * initial 入口 chunk，对于异步导入的文件不处理
                async 异步 chunk，只对异步导入的文件处理
                all 全部 chunk
             */

            // 缓存分组
            cacheGroups: {
                // 第三方模块
                vendor: {
                    name: 'vendor', // chunk 名称
                    priority: 1, // 权限更高，优先抽离，重要！！！
                    test: /node_modules/,
                    minSize: 0,  // 大小限制
                    minChunks: 1  // 最少复用过几次
                },

                // 公共的模块
                common: {
                    name: 'common', // chunk 名称
                    priority: 0, // 优先级
                    minSize: 0,  // 公共模块的大小限制
                    minChunks: 2  // 公共模块最少复用过几次
                }
            }
        }
    }
```
# module chunk bundle的区别
1. module - 各个源码文件，webpack中一切皆模块
2. chunk - 多模块合并成的，如entry import() splitChunk
3. bundle - 最终的输出文件

# webpack性能优化
1. 优化打包构件速度 - 开发体验和效率
2. 优化产出代码 - 产品性能

## 构建速度
1. 优化babel-loader
2. IgnorePlugin
3. noParse
4. happyPack
5. ParallelUglifyPlugin
6. 自动刷新
7. 热更新
8. DllPlugin

### 优化babel-loader
```js
{
    test: /\.js$/,
    loader: ['babel-loader?cacheDirectory'], //开启缓存
    include: path.resolve(_dirname,'src'), // 明确范围
    // 排除范围，include和exclude两者选一即可
    //exclude:path.resolve(_dirname,'node_modules')
}
```
### happyPack多进程打包
- js单线程，开启多进程打包
- 提高构件速度（特别是多核CPU）

1. 安装happyPack
2. 删除common下的babel-loader
3. 将babel放入dev
4. 将happyPack导入添加loader？id=babel
5. plugins内new一个HappyPack且id：babel

### ParallelUglifyPlugin多进程压缩js
1. wabpack内置Uglify工具压缩JS
2. JS单线程，开启多进程压缩更快

### 关于开启多线程
1. 项目较大，打包较慢，开启多进程能提高性能
2. 项目较小，打包很卡，多进程会降低速度 （进程开销）

### 热更新
自动刷新是刷新整个页面，
1. 速度慢
2. 状态丢失

热更新：新代码生效，网页不刷新，状态不丢失
HotModuleReplacementPlugin
代码可见webpack-demo-optimization

```js
// 增加，开启热更新之后的代码逻辑
if (module.hot) {
    module.hot.accept(['./math'], () => {
        const sumRes = sum(10, 30)
        console.log('sumRes in hot', sumRes)
    })
}
```
必须在代码内设置监听热更新范围